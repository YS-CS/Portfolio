# -*- coding: utf-8 -*-
"""TicTacToe w/ AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wid7oU0KVkN8KwTMGXeemWrwY3BCyefc
"""

# Version: 1.0 - Tic Tac Toes w/ AI

# Things to add can be AI difficulty and perhaps grid size change

# Makes array like grid of 9
board = [" "] * 9

# Tracks the
scores = {
    "player": 0,
    "computer": 0,
    "draws": 0
}

def print_board(b):
    """For X or O to be bold - easier to see"""
    BOLD = "\033[1m"
    RESET = "\033[0m"

    print()
    for index, value in enumerate(b):
        if value == " ":
            mark = str(index + 1)      # Show numbers instead of empty slots for ease of use
        else:
            mark = f"{BOLD}{value}{RESET}"

        end_char = " | " if (index + 1) % 3 != 0 else "\n"
        print(mark, end=end_char)

        if (index + 1) % 3 == 0 and index < 8:
            print("--+---+--")
    print()


def check_win(b, player):
    """Check if a given player has a winning combo."""
    combos = [
        [0,1,2], [3,4,5], [6,7,8],  # rows
        [0,3,6], [1,4,7], [2,5,8],  # columns
        [0,4,8], [2,4,6]            # diagonals
    ]
    for c in combos:
        if b[c[0]] == player and b[c[1]] == player and b[c[2]] == player:
            return True
    return False


def empty_slots(b):
    return [i for i, v in enumerate(b) if v == " "]


import random

def computer_move():
    """Very simple bot - AI:
       1. Try to win
       2. Block player
       3. Random choice
    """
    # finding an empty spot
    for move in empty_slots(board):
        board[move] = "O"
        if check_win(board, "O"):
            return
        board[move] = " "

    # essentially tries to find x and go next to it for a block
    for move in empty_slots(board):
        board[move] = "X"
        if check_win(board, "X"):
            board[move] = "O"
            return
        board[move] = " "

    # Rnadom movement for the ai bot (O)
    rand_move = random.choice(empty_slots(board))
    board[rand_move] = "O"


def reset_board():
    """Clear board for new round."""
    for i in range(len(board)):
        board[i] = " "


def display_scores():
    print(f"Scores => You: {scores['player']} | Computer: {scores['computer']} | Draws: {scores['draws']}")


def play():
    print("Welcome to Tic Tac Toe!")
    print("You play as X\n")

    while True:
        reset_board()
        print_board(board)

        while True:
            try:
                move = int(input("Pick a spot (1-9): ")) - 1
            except ValueError:
                print("That's not a number.")
                continue

            if move not in empty_slots(board):
                print("Spot already taken or invalid.")
                continue

            board[move] = "X"
            print_board(board)

            # Adds a point according to who won out of (X, O or draw)
            if check_win(board, "X"):
                print("You win!")
                scores["player"] += 1
                break

            if len(empty_slots(board)) == 0:
                print("It's a draw.")
                scores["draws"] += 1
                break

            computer_move()
            print("\nComputer moved:")
            print_board(board)

            if check_win(board, "O"):
                print("Computer wins.")
                scores["computer"] += 1
                break

        display_scores()

        choice = input("\nPlay again? (y), reset scores (r), or quit (anything else): ").lower()
        if choice == "r":
            for key in scores:
                scores[key] = 0
            print("Scores reset.\n")
        elif choice != "y":
            print("Goodbye!")
            break


play()